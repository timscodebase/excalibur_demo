import { Ray } from '../Math/ray';
import { DeepRequired } from '../Util/Required';
import { Observable } from '../Util/Observable';
import { DynamicTreeCollisionProcessor, RayCastHit, RayCastOptions } from './Index';
import { PhysicsConfig } from './PhysicsConfig';
export declare class PhysicsWorld {
    $configUpdate: Observable<Required<{
        enabled?: boolean;
        gravity?: import("..").Vector;
        solver?: import("./SolverStrategy").SolverStrategy;
        colliders?: Required<{
            compositeStrategy?: "separate" | "together";
        }>;
        continuous?: Required<{
            checkForFastBodies?: boolean;
            disableMinimumSpeedForFastBody?: boolean;
            surfaceEpsilon?: number;
        }>;
        bodies?: Required<{
            defaultMass?: number;
            sleepEpsilon?: number;
            wakeThreshold?: number;
            sleepBias?: number;
            canSleepByDefault?: boolean;
        }>;
        dynamicTree?: Required<{
            boundsPadding?: number;
            velocityMultiplier?: number;
        }>;
        arcade?: Required<{
            contactSolveBias?: import("./Index").ContactSolveBias;
        }>;
        realistic?: Required<{
            positionIterations?: number;
            velocityIterations?: number;
            slop?: number;
            steeringFactor?: number;
            warmStart?: boolean;
        }>;
    }>>;
    private _configDirty;
    private _config;
    get config(): DeepRequired<PhysicsConfig>;
    set config(newConfig: DeepRequired<PhysicsConfig>);
    private _collisionProcessor;
    /**
     * Spatial data structure for locating potential collision pairs and ray casts
     */
    get collisionProcessor(): DynamicTreeCollisionProcessor;
    constructor(config: DeepRequired<PhysicsConfig>);
    /**
     * Raycast into the scene's physics world
     * @param ray
     * @param options
     */
    rayCast(ray: Ray, options?: RayCastOptions): RayCastHit[];
}
