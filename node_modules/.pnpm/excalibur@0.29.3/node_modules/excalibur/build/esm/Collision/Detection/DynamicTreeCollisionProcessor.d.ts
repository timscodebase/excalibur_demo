import { CollisionProcessor } from './CollisionProcessor';
import { Pair } from './Pair';
import { Ray } from '../../Math/ray';
import { FrameStats } from '../../Debug';
import { Collider } from '../Colliders/Collider';
import { CollisionContact } from '../Detection/CollisionContact';
import { CollisionGroup } from '../Group/CollisionGroup';
import { ExcaliburGraphicsContext } from '../../Graphics/Context/ExcaliburGraphicsContext';
import { RayCastHit } from './RayCastHit';
import { DeepRequired } from '../../Util/Required';
import { PhysicsConfig } from '../PhysicsConfig';
export interface RayCastOptions {
    /**
     * Optionally specify the maximum distance in pixels to ray cast, default is Infinity
     */
    maxDistance?: number;
    /**
     * Optionally specify a collision group to target in the ray cast, default is All.
     */
    collisionGroup?: CollisionGroup;
    /**
     * Optionally specify a collision mask to target multiple collision categories
     */
    collisionMask?: number;
    /**
     * Optionally specify to search for all colliders that intersect the ray cast, not just the first which is the default
     */
    searchAllColliders?: boolean;
    /**
     * Optionally ignore things with CollisionGroup.All and only test against things with an explicit group
     *
     * Default false
     */
    ignoreCollisionGroupAll?: boolean;
    /**
     * Optionally provide a any filter function to filter on arbitrary qualities of a ray cast hit
     *
     * Filters run after any collision mask/collision group filtering, it is the last decision
     *
     * Returning true means you want to include the collider in your results, false means exclude it
     */
    filter?: (hit: RayCastHit) => boolean;
}
/**
 * Responsible for performing the collision broadphase (locating potential collisions) and
 * the narrowphase (actual collision contacts)
 */
export declare class DynamicTreeCollisionProcessor implements CollisionProcessor {
    private _config;
    private _dynamicCollisionTree;
    private _pairs;
    private _collisionPairCache;
    private _colliders;
    constructor(_config: DeepRequired<PhysicsConfig>);
    getColliders(): readonly Collider[];
    rayCast(ray: Ray, options?: RayCastOptions): RayCastHit[];
    /**
     * Tracks a physics body for collisions
     */
    track(target: Collider): void;
    /**
     * Untracks a physics body
     */
    untrack(target: Collider): void;
    private _pairExists;
    /**
     * Detects potential collision pairs in a broadphase approach with the dynamic AABB tree strategy
     */
    broadphase(targets: Collider[], delta: number, stats?: FrameStats): Pair[];
    /**
     * Applies narrow phase on collision pairs to find actual area intersections
     * Adds actual colliding pairs to stats' Frame data
     */
    narrowphase(pairs: Pair[], stats?: FrameStats): CollisionContact[];
    /**
     * Update the dynamic tree positions
     */
    update(targets: Collider[]): number;
    debug(ex: ExcaliburGraphicsContext): void;
}
