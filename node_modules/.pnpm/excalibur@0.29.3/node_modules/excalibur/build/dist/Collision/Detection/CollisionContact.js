import { CollisionType } from '../CollisionType';
import { Pair } from './Pair';
import { BodyComponent } from '../BodyComponent';
/**
 * Collision contacts are used internally by Excalibur to resolve collision between colliders. This
 * Pair prevents collisions from being evaluated more than one time
 */
export class CollisionContact {
    constructor(colliderA, colliderB, mtv, normal, tangent, points, localPoints, info) {
        var _a, _b, _c, _d, _e, _f;
        this._canceled = false;
        this.colliderA = colliderA;
        this.colliderB = colliderB;
        this.mtv = mtv;
        this.normal = normal;
        this.tangent = tangent;
        this.points = points;
        this.localPoints = localPoints;
        this.info = info;
        this.id = Pair.calculatePairHash(colliderA.id, colliderB.id);
        if (colliderA.composite || colliderB.composite) {
            // Add on the parent composite pair for start/end contact if 'together
            const colliderAId = ((_a = colliderA.composite) === null || _a === void 0 ? void 0 : _a.compositeStrategy) === 'separate' ? colliderA.id : (_c = (_b = colliderA.composite) === null || _b === void 0 ? void 0 : _b.id) !== null && _c !== void 0 ? _c : colliderA.id;
            const colliderBId = ((_d = colliderB.composite) === null || _d === void 0 ? void 0 : _d.compositeStrategy) === 'separate' ? colliderB.id : (_f = (_e = colliderB.composite) === null || _e === void 0 ? void 0 : _e.id) !== null && _f !== void 0 ? _f : colliderB.id;
            this.id += '|' + Pair.calculatePairHash(colliderAId, colliderBId);
        }
    }
    /**
     * Match contact awake state, except if body's are Fixed
     */
    matchAwake() {
        const bodyA = this.colliderA.owner.get(BodyComponent);
        const bodyB = this.colliderB.owner.get(BodyComponent);
        if (bodyA && bodyB) {
            if (bodyA.sleeping !== bodyB.sleeping) {
                if (bodyA.sleeping && bodyA.collisionType !== CollisionType.Fixed && bodyB.sleepMotion >= bodyA.wakeThreshold) {
                    bodyA.setSleeping(false);
                }
                if (bodyB.sleeping && bodyB.collisionType !== CollisionType.Fixed && bodyA.sleepMotion >= bodyB.wakeThreshold) {
                    bodyB.setSleeping(false);
                }
            }
        }
    }
    isCanceled() {
        return this._canceled;
    }
    cancel() {
        this._canceled = true;
    }
}
//# sourceMappingURL=CollisionContact.js.map