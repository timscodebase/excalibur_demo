import { Engine } from './Engine';
import { Vector } from './Math/vector';
import { ExitTriggerEvent, EnterTriggerEvent, CollisionEndEvent, CollisionStartEvent } from './Events';
import { Entity } from './EntityComponentSystem';
import { Actor, ActorEvents } from './Actor';
import { EventEmitter } from './EventEmitter';
export type TriggerEvents = ActorEvents & {
    exit: ExitTriggerEvent;
    enter: EnterTriggerEvent;
};
export declare const TriggerEvents: {
    ExitTrigger: string;
    EnterTrigger: string;
};
/**
 * TriggerOptions
 */
export interface TriggerOptions {
    pos: Vector;
    width: number;
    height: number;
    visible: boolean;
    action: () => void;
    target: Entity;
    filter: (actor: Entity) => boolean;
    repeat: number;
}
/**
 * Triggers are a method of firing arbitrary code on collision. These are useful
 * as 'buttons', 'switches', or to trigger effects in a game. By default triggers
 * are invisible, and can only be seen when [[Trigger.visible]] is set to `true`.
 */
export declare class Trigger extends Actor {
    events: EventEmitter<import("./EntityComponentSystem").EntityEvents & {
        collisionstart: CollisionStartEvent<Actor>;
        collisionend: CollisionEndEvent<Actor>;
        precollision: import("./Events").PreCollisionEvent<Actor>;
        postcollision: import("./Events").PostCollisionEvent<Actor>;
        kill: import("./Events").KillEvent;
        prekill: import("./Events").PreKillEvent;
        postkill: import("./Events").PostKillEvent;
        predraw: import("./Events").PreDrawEvent;
        postdraw: import("./Events").PostDrawEvent;
        pretransformdraw: import("./Events").PreDrawEvent;
        posttransformdraw: import("./Events").PostDrawEvent;
        predebugdraw: import("./Events").PreDebugDrawEvent;
        postdebugdraw: import("./Events").PostDebugDrawEvent;
        pointerup: import("./excalibur").PointerEvent;
        pointerdown: import("./excalibur").PointerEvent;
        pointerenter: import("./excalibur").PointerEvent;
        pointerleave: import("./excalibur").PointerEvent;
        pointermove: import("./excalibur").PointerEvent;
        pointercancel: import("./excalibur").PointerEvent;
        pointerwheel: import("./excalibur").WheelEvent;
        pointerdragstart: import("./excalibur").PointerEvent;
        pointerdragend: import("./excalibur").PointerEvent;
        pointerdragenter: import("./excalibur").PointerEvent;
        pointerdragleave: import("./excalibur").PointerEvent;
        pointerdragmove: import("./excalibur").PointerEvent;
        enterviewport: import("./Events").EnterViewPortEvent;
        exitviewport: import("./Events").ExitViewPortEvent;
        actionstart: import("./Events").ActionStartEvent;
        actioncomplete: import("./Events").ActionCompleteEvent;
    } & {
        exit: ExitTriggerEvent;
        enter: EnterTriggerEvent;
    }>;
    private _target;
    /**
     * Action to fire when triggered by collision
     */
    action: () => void;
    /**
     * Filter to add additional granularity to action dispatch, if a filter is specified the action will only fire when
     * filter return true for the collided actor.
     */
    filter: (actor: Entity) => boolean;
    /**
     * Number of times to repeat before killing the trigger,
     */
    repeat: number;
    /**
     *
     * @param opts Trigger options
     */
    constructor(opts: Partial<TriggerOptions>);
    set target(target: Entity);
    get target(): Entity;
    _initialize(engine: Engine): void;
    private _dispatchAction;
}
