/* eslint-disable no-console */
import { vec } from '../Math/vector';
import { Color } from '../Color';
/**
 * Logging level that Excalibur will tag
 */
export var LogLevel;
(function (LogLevel) {
    LogLevel[LogLevel["Debug"] = 0] = "Debug";
    LogLevel[LogLevel["Info"] = 1] = "Info";
    LogLevel[LogLevel["Warn"] = 2] = "Warn";
    LogLevel[LogLevel["Error"] = 3] = "Error";
    LogLevel[LogLevel["Fatal"] = 4] = "Fatal";
})(LogLevel || (LogLevel = {}));
/**
 * Static singleton that represents the logging facility for Excalibur.
 * Excalibur comes built-in with a [[ConsoleAppender]] and [[ScreenAppender]].
 * Derive from [[Appender]] to create your own logging appenders.
 */
export class Logger {
    constructor() {
        this._appenders = [];
        /**
         * Gets or sets the default logging level. Excalibur will only log
         * messages if equal to or above this level. Default: [[LogLevel.Info]]
         */
        this.defaultLevel = LogLevel.Info;
        this._logOnceSet = new Set();
        if (Logger._INSTANCE) {
            throw new Error('Logger is a singleton');
        }
        Logger._INSTANCE = this;
        // Default console appender
        Logger._INSTANCE.addAppender(new ConsoleAppender());
        return Logger._INSTANCE;
    }
    /**
     * Gets the current static instance of Logger
     */
    static getInstance() {
        if (Logger._INSTANCE == null) {
            Logger._INSTANCE = new Logger();
        }
        return Logger._INSTANCE;
    }
    /**
     * Adds a new [[Appender]] to the list of appenders to write to
     */
    addAppender(appender) {
        this._appenders.push(appender);
    }
    /**
     * Clears all appenders from the logger
     */
    clearAppenders() {
        this._appenders.length = 0;
    }
    /**
     * Logs a message at a given LogLevel
     * @param level  The LogLevel`to log the message at
     * @param args   An array of arguments to write to an appender
     */
    _log(level, args) {
        if (level == null) {
            level = this.defaultLevel;
        }
        const len = this._appenders.length;
        for (let i = 0; i < len; i++) {
            if (level >= this.defaultLevel) {
                this._appenders[i].log(level, args);
            }
        }
    }
    _logOnce(level, args) {
        const serialized = level + args.join('+');
        if (this._logOnceSet.has(serialized)) {
            return;
        }
        else {
            this._logOnceSet.add(serialized);
            this._log(level, args);
        }
    }
    /**
     * Writes a log message at the [[LogLevel.Debug]] level
     * @param args  Accepts any number of arguments
     */
    debug(...args) {
        this._log(LogLevel.Debug, args);
    }
    /**
     * Writes a log message once at the [[LogLevel.Fatal]] level, if it sees the same args again it wont log
     * @param args  Accepts any number of arguments
     */
    debugOnce(...args) {
        this._logOnce(LogLevel.Debug, args);
    }
    /**
     * Writes a log message at the [[LogLevel.Info]] level
     * @param args  Accepts any number of arguments
     */
    info(...args) {
        this._log(LogLevel.Info, args);
    }
    /**
     * Writes a log message once at the [[LogLevel.Info]] level, if it sees the same args again it wont log
     * @param args  Accepts any number of arguments
     */
    infoOnce(...args) {
        this._logOnce(LogLevel.Info, args);
    }
    /**
     * Writes a log message at the [[LogLevel.Warn]] level
     * @param args  Accepts any number of arguments
     */
    warn(...args) {
        this._log(LogLevel.Warn, args);
    }
    /**
     * Writes a log message once at the [[LogLevel.Warn]] level, if it sees the same args again it won't log
     * @param args  Accepts any number of arguments
     */
    warnOnce(...args) {
        this._logOnce(LogLevel.Warn, args);
    }
    /**
     * Writes a log message at the [[LogLevel.Error]] level
     * @param args  Accepts any number of arguments
     */
    error(...args) {
        this._log(LogLevel.Error, args);
    }
    /**
     * Writes a log message once at the [[LogLevel.Error]] level, if it sees the same args again it won't log
     * @param args  Accepts any number of arguments
     */
    errorOnce(...args) {
        this._logOnce(LogLevel.Error, args);
    }
    /**
     * Writes a log message at the [[LogLevel.Fatal]] level
     * @param args  Accepts any number of arguments
     */
    fatal(...args) {
        this._log(LogLevel.Fatal, args);
    }
    /**
     * Writes a log message once at the [[LogLevel.Fatal]] level, if it sees the same args again it won't log
     * @param args  Accepts any number of arguments
     */
    fatalOnce(...args) {
        this._logOnce(LogLevel.Fatal, args);
    }
}
Logger._INSTANCE = null;
/**
 * Console appender for browsers (i.e. `console.log`)
 */
export class ConsoleAppender {
    /**
     * Logs a message at the given [[LogLevel]]
     * @param level  Level to log at
     * @param args   Arguments to log
     */
    log(level, args) {
        // Check for console support
        if (!console && !console.log && console.warn && console.error) {
            // todo maybe do something better than nothing
            return;
        }
        // Create a new console args array
        const consoleArgs = [];
        consoleArgs.unshift.apply(consoleArgs, args);
        consoleArgs.unshift('[' + LogLevel[level] + '] : ');
        if (level < LogLevel.Warn) {
            // Call .log for Debug/Info
            if (console.log.apply) {
                // this is required on some older browsers that don't support apply on console.log :(
                console.log.apply(console, consoleArgs);
            }
            else {
                console.log(consoleArgs.join(' '));
            }
        }
        else if (level < LogLevel.Error) {
            // Call .warn for Warn
            if (console.warn.apply) {
                console.warn.apply(console, consoleArgs);
            }
            else {
                console.warn(consoleArgs.join(' '));
            }
        }
        else {
            // Call .error for Error/Fatal
            if (console.error.apply) {
                console.error.apply(console, consoleArgs);
            }
            else {
                console.error(consoleArgs.join(' '));
            }
        }
    }
}
/**
 * On-screen (canvas) appender
 */
export class ScreenAppender {
    constructor(options) {
        var _a, _b;
        this._messages = [];
        this._pos = 10;
        this._color = Color.Black;
        this._options = options;
        this.canvas = document.createElement('canvas');
        this._ctx = this.canvas.getContext('2d');
        this.canvas.style.position = 'absolute';
        this.canvas.style.zIndex = (_b = (_a = options.zIndex) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : '99';
        document.body.appendChild(this.canvas);
        this._positionScreenAppenderCanvas();
        options.engine.screen.events.on('resize', () => {
            this._positionScreenAppenderCanvas();
        });
    }
    _positionScreenAppenderCanvas() {
        var _a, _b, _c, _d;
        const options = this._options;
        this.canvas.width = (_a = options.width) !== null && _a !== void 0 ? _a : options.engine.screen.resolution.width;
        this.canvas.height = (_b = options.height) !== null && _b !== void 0 ? _b : options.engine.screen.resolution.height;
        this.canvas.style.position = 'absolute';
        const pagePos = options.engine.screen.screenToPageCoordinates(vec(0, 0));
        this.canvas.style.left = pagePos.x + 'px';
        this.canvas.style.top = pagePos.y + 'px';
        this._pos = (_c = options.xPos) !== null && _c !== void 0 ? _c : this._pos;
        this._color = (_d = options.color) !== null && _d !== void 0 ? _d : this._color;
    }
    /**
     * Logs a message at the given [[LogLevel]]
     * @param level  Level to log at
     * @param args   Arguments to log
     */
    log(level, args) {
        const message = args.join(',');
        this._ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this._messages.unshift('[' + LogLevel[level] + '] : ' + message);
        let pos = 10;
        this._messages = this._messages.slice(0, 1000);
        for (let i = 0; i < this._messages.length; i++) {
            this._ctx.fillStyle = this._color.toRGBA();
            this._ctx.fillText(this._messages[i], this._pos, pos);
            pos += 10;
        }
    }
}
//# sourceMappingURL=Log.js.map