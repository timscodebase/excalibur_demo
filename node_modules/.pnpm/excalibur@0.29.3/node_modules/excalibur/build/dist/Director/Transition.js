import { Future } from '../Util/Future';
import { Entity, TransformComponent } from '../EntityComponentSystem';
import { GraphicsComponent } from '../Graphics';
import { CoordPlane } from '../Math/coord-plane';
import { Vector } from '../Math/vector';
import { clamp } from '../Math/util';
import { EasingFunctions } from '../Util/EasingFunctions';
import { coroutine } from '../Util/Coroutine';
import { Logger } from '../Util/Log';
/**
 * Base Transition that can be extended to provide custom scene transitions in Excalibur.
 */
export class Transition extends Entity {
    /**
     * Returns a number between [0, 1] indicating what state the transition is in.
     *
     * * For 'out' direction transitions start at 0 and end at 1
     * * For 'in' direction transitions start at 1 and end at 0
     */
    get progress() {
        return this._currentProgress;
    }
    get complete() {
        if (this.direction === 'out') {
            return this.progress >= 1;
        }
        else {
            return this.progress <= 0;
        }
    }
    constructor(options) {
        var _a, _b, _c, _d;
        super();
        this._logger = Logger.getInstance();
        this.transform = new TransformComponent();
        this.graphics = new GraphicsComponent();
        this._completeFuture = new Future();
        // State needs to be reset between uses
        this.started = false;
        this._currentDistance = 0;
        this._currentProgress = 0;
        this.done = this._completeFuture.promise;
        this.name = `Transition#${this.id}`;
        this.duration = options.duration;
        this.easing = (_a = options.easing) !== null && _a !== void 0 ? _a : EasingFunctions.Linear;
        this.direction = (_b = options.direction) !== null && _b !== void 0 ? _b : 'out';
        this.hideLoader = (_c = options.hideLoader) !== null && _c !== void 0 ? _c : false;
        this.blockInput = (_d = options.blockInput) !== null && _d !== void 0 ? _d : false;
        this.transform.coordPlane = CoordPlane.Screen;
        this.transform.pos = Vector.Zero;
        this.transform.z = Infinity; // Transitions sit on top of everything
        this.graphics.anchor = Vector.Zero;
        this.addComponent(this.transform);
        this.addComponent(this.graphics);
        if (this.direction === 'out') {
            this._currentProgress = 0;
        }
        else {
            this._currentProgress = 1;
        }
    }
    /**
     * Overridable lifecycle method, called before each update.
     *
     * **WARNING BE SURE** to call `super.updateTransition()` if overriding in your own custom implementation
     * @param engine
     * @param delta
     */
    updateTransition(engine, delta) {
        if (this.complete) {
            return;
        }
        this._currentDistance += clamp(delta / this.duration, 0, 1);
        if (this._currentDistance >= 1) {
            this._currentDistance = 1;
        }
        if (this.direction === 'out') {
            this._currentProgress = clamp(this.easing(this._currentDistance, 0, 1, 1), 0, 1);
        }
        else {
            this._currentProgress = clamp(this.easing(this._currentDistance, 1, 0, 1), 0, 1);
        }
    }
    /**
     * Overridable lifecycle method, called right before the previous scene has deactivated.
     *
     * This gives incoming transition a chance to grab info from previous scene if desired
     * @param scene
     */
    async onPreviousSceneDeactivate(scene) {
        // override me
    }
    /**
     * Overridable lifecycle method, called once at the beginning of the transition
     *
     * `progress` is given between 0 and 1
     * @param progress
     */
    onStart(progress) {
        // override me
    }
    /**
     * Overridable lifecycle method, called every frame of the transition
     *
     * `progress` is given between 0 and 1
     * @param progress
     */
    onUpdate(progress) {
        // override me
    }
    /**
     * Overridable lifecycle method, called at the end of the transition,
     *
     * `progress` is given between 0 and 1
     * @param progress
     */
    onEnd(progress) {
        // override me
    }
    /**
     * Overridable lifecycle method, called when the transition is reset
     *
     * Use this to override and provide your own reset logic for internal state in custom transition implementations
     */
    onReset() {
        // override me
    }
    /**
     * reset() is called by the engine to reset transitions
     */
    reset() {
        this.started = false;
        this._completeFuture = new Future();
        this.done = this._completeFuture.promise;
        this._currentDistance = 0;
        if (this.direction === 'out') {
            this._currentProgress = 0;
        }
        else {
            this._currentProgress = 1;
        }
        this.onReset();
    }
    play(engine, targetScene) {
        if (this.started) {
            this.reset();
            this._logger.warn(`Attempted to play a transition ${this.name} that is already playing, reset transition.`);
        }
        const currentScene = targetScene !== null && targetScene !== void 0 ? targetScene : engine.currentScene;
        currentScene.add(this);
        const self = this;
        return coroutine(engine, function* () {
            while (!self.complete) {
                const elapsed = yield; // per frame
                self.updateTransition(engine, elapsed);
                self.execute();
            }
        });
    }
    /**
     * execute() is called by the engine every frame to update the Transition lifecycle onStart/onUpdate/onEnd
     */
    execute() {
        if (!this.isInitialized) {
            return;
        }
        if (!this.started) {
            this.started = true;
            this.onStart(this.progress);
        }
        this.onUpdate(this.progress);
        if (this.complete && !this._completeFuture.isCompleted) {
            this.onEnd(this.progress);
            this._completeFuture.resolve();
        }
    }
}
//# sourceMappingURL=Transition.js.map