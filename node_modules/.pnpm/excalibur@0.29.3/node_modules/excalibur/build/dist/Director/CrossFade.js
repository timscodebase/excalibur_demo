import { ImageSource } from '../Graphics';
import { Transition } from './Transition';
import { vec } from '../Math/vector';
/**
 * CrossFades between the previous scene and the destination scene
 *
 * Note: CrossFade only works as an "in" transition
 */
export class CrossFade extends Transition {
    constructor(options) {
        super({ direction: 'in', ...options }); // default the correct direction
        this.name = `CrossFade#${this.id}`;
    }
    async onPreviousSceneDeactivate(scene) {
        this.image = await scene.engine.screenshot(true);
        // Firefox is particularly slow
        // needed in case the image isn't ready yet
        await this.image.decode();
    }
    onInitialize(engine) {
        this.engine = engine;
        this.transform.pos = engine.screen.unsafeArea.topLeft;
        this.screenCover = ImageSource.fromHtmlImageElement(this.image).toSprite();
        this.graphics.add(this.screenCover);
        this.transform.scale = vec(1 / engine.screen.pixelRatio, 1 / engine.screen.pixelRatio);
        this.graphics.opacity = this.progress;
    }
    onStart(_progress) {
        this.graphics.opacity = this.progress;
    }
    onReset() {
        this.graphics.opacity = this.progress;
    }
    onEnd(progress) {
        this.graphics.opacity = progress;
    }
    onUpdate(progress) {
        this.graphics.opacity = progress;
    }
}
//# sourceMappingURL=CrossFade.js.map