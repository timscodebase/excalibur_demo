import { Color } from '../../Color';
import { ExcaliburGraphicsContextWebGL } from './ExcaliburGraphicsContextWebGL';
import { Logger } from '../../Util/Log';
import { ImageSourceAttributeConstants } from '../ImageSource';
import { parseImageFiltering } from '../Filtering';
import { parseImageWrapping } from '../Wrapping';
const defaultVertexSource = `#version 300 es
in vec2 a_position;

in vec2 a_uv;
out vec2 v_uv;

in vec2 a_screenuv;
out vec2 v_screenuv;

uniform mat4 u_matrix;
uniform mat4 u_transform;

void main() {
  // Set the vertex position using the ortho & transform matrix
  gl_Position = u_matrix * u_transform * vec4(a_position, 0.0, 1.0);

  // Pass through the UV coord to the fragment shader
  v_uv = a_uv;
  v_screenuv = a_screenuv;
}
`;
export class Material {
    constructor(options) {
        this._logger = Logger.getInstance();
        this._color = Color.Transparent;
        this._initialized = false;
        this._images = new Map();
        this._textures = new Map();
        const { color, name, vertexSource, fragmentSource, graphicsContext, images } = options;
        this._name = name !== null && name !== void 0 ? name : 'anonymous material';
        this._vertexSource = vertexSource !== null && vertexSource !== void 0 ? vertexSource : defaultVertexSource;
        this._fragmentSource = fragmentSource;
        this._color = color !== null && color !== void 0 ? color : this._color;
        if (!graphicsContext) {
            throw Error(`Material ${name} must be provided an excalibur webgl graphics context`);
        }
        if (graphicsContext instanceof ExcaliburGraphicsContextWebGL) {
            this._graphicsContext = graphicsContext;
            this._initialize(graphicsContext);
        }
        else {
            this._logger.warn(`Material ${name} was created in 2D Canvas mode, currently only WebGL is supported`);
        }
        if (images) {
            for (const key in images) {
                this.addImageSource(key, images[key]);
            }
        }
    }
    _initialize(graphicsContextWebGL) {
        if (this._initialized) {
            return;
        }
        const gl = graphicsContextWebGL.__gl;
        // max texture slots - 2 for the graphic texture and screen texture
        this._maxTextureSlots = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS) - 2;
        this._shader = graphicsContextWebGL.createShader({
            vertexSource: this._vertexSource,
            fragmentSource: this._fragmentSource
        });
        this._shader.compile();
        this._initialized = true;
    }
    get name() {
        var _a;
        return (_a = this._name) !== null && _a !== void 0 ? _a : 'anonymous material';
    }
    get isUsingScreenTexture() {
        return this._fragmentSource.includes('u_screen_texture');
    }
    update(callback) {
        if (this._shader) {
            this._shader.use();
            callback(this._shader);
        }
    }
    getShader() {
        return this._shader;
    }
    addImageSource(textureUniformName, image) {
        if (this._images.size < this._maxTextureSlots) {
            this._images.set(textureUniformName, image);
        }
        else {
            this._logger.warn(`Max number texture slots ${this._maxTextureSlots} have been reached for material "${this.name}", ` +
                `no more textures will be uploaded due to hardware constraints.`);
        }
    }
    removeImageSource(textureName) {
        const image = this._images.get(textureName);
        this._graphicsContext.textureLoader.delete(image.image);
        this._images.delete(textureName);
    }
    _loadImageSource(image) {
        const imageElement = image.image;
        const maybeFiltering = imageElement.getAttribute(ImageSourceAttributeConstants.Filtering);
        const filtering = maybeFiltering ? parseImageFiltering(maybeFiltering) : null;
        const wrapX = parseImageWrapping(imageElement.getAttribute(ImageSourceAttributeConstants.WrappingX));
        const wrapY = parseImageWrapping(imageElement.getAttribute(ImageSourceAttributeConstants.WrappingY));
        const force = imageElement.getAttribute('forceUpload') === 'true' ? true : false;
        const texture = this._graphicsContext.textureLoader.load(imageElement, {
            filtering,
            wrapping: { x: wrapX, y: wrapY }
        }, force);
        // remove force attribute after upload
        imageElement.removeAttribute('forceUpload');
        if (!this._textures.has(image)) {
            this._textures.set(image, texture);
        }
        return texture;
    }
    uploadAndBind(gl, startingTextureSlot = 2) {
        let textureSlot = startingTextureSlot;
        for (const [textureName, image] of this._images.entries()) {
            if (!image.isLoaded()) {
                this._logger.warnOnce(`Image named ${textureName} in material ${this.name} not loaded, nothing will be uploaded to the shader.` +
                    ` Did you forget to add this to a loader? https://excaliburjs.com/docs/loaders/`);
                continue;
            } // skip unloaded images, maybe warn
            const texture = this._loadImageSource(image);
            gl.activeTexture(gl.TEXTURE0 + textureSlot);
            gl.bindTexture(gl.TEXTURE_2D, texture);
            this._shader.trySetUniformInt(textureName, textureSlot);
            textureSlot++;
        }
    }
    use() {
        if (this._initialized) {
            // bind the shader
            this._shader.use();
            // Apply standard uniforms
            this._shader.trySetUniformFloatColor('u_color', this._color);
        }
        else {
            throw Error(`Material ${this.name} not yet initialized, use the ExcaliburGraphicsContext.createMaterial() to work around this.`);
        }
    }
}
//# sourceMappingURL=material.js.map