import { Vector } from '../Math/vector';
import { Graphic } from './Graphic';
import { Animation } from './Animation';
import { BoundingBox } from '../Collision/Index';
import { Logger } from '../Util/Log';
export class GraphicsGroup extends Graphic {
    constructor(options) {
        var _a;
        super(options);
        this._logger = Logger.getInstance();
        this.useAnchor = true;
        this.members = [];
        this.members = options.members;
        this.useAnchor = (_a = options.useAnchor) !== null && _a !== void 0 ? _a : this.useAnchor;
        this._updateDimensions();
    }
    clone() {
        return new GraphicsGroup({
            members: [...this.members],
            ...this.cloneGraphicOptions()
        });
    }
    _updateDimensions() {
        const bb = this.localBounds;
        this.width = bb.width;
        this.height = bb.height;
        return bb;
    }
    get localBounds() {
        let bb = new BoundingBox();
        for (const member of this.members) {
            if (member instanceof Graphic) {
                bb = member.localBounds.combine(bb);
            }
            else {
                const { graphic, offset: pos, useBounds } = member;
                const shouldUseBounds = useBounds === undefined ? true : useBounds;
                if (graphic) {
                    if (shouldUseBounds) {
                        bb = graphic.localBounds.translate(pos).combine(bb);
                    }
                }
                else {
                    this._logger.warnOnce(`Graphics group member has an null or undefined graphic, member definition: ${JSON.stringify(member)}.`);
                }
            }
        }
        return bb;
    }
    _isAnimationOrGroup(graphic) {
        return graphic instanceof Animation || graphic instanceof GraphicsGroup;
    }
    tick(elapsedMilliseconds, idempotencyToken) {
        for (const member of this.members) {
            let graphic;
            if (member instanceof Graphic) {
                graphic = member;
            }
            else {
                graphic = member.graphic;
            }
            if (this._isAnimationOrGroup(graphic)) {
                graphic.tick(elapsedMilliseconds, idempotencyToken);
            }
        }
    }
    reset() {
        for (const member of this.members) {
            let graphic;
            if (member instanceof Graphic) {
                graphic = member;
            }
            else {
                graphic = member.graphic;
            }
            if (this._isAnimationOrGroup(graphic)) {
                graphic.reset();
            }
        }
    }
    _preDraw(ex, x, y) {
        this._updateDimensions();
        super._preDraw(ex, this.useAnchor ? x : 0, this.useAnchor ? y : 0);
    }
    _drawImage(ex, x, y) {
        const pos = Vector.Zero;
        for (const member of this.members) {
            let graphic;
            if (member instanceof Graphic) {
                graphic = member;
            }
            else {
                graphic = member.graphic;
                member.offset.clone(pos);
            }
            if (!graphic) {
                continue;
            }
            ex.save();
            ex.translate(x, y);
            graphic.draw(ex, pos.x, pos.y);
            if (this.showDebug) {
                /* istanbul ignore next */
                ex.debug.drawRect(0, 0, this.width, this.height);
            }
            ex.restore();
        }
    }
}
//# sourceMappingURL=GraphicsGroup.js.map