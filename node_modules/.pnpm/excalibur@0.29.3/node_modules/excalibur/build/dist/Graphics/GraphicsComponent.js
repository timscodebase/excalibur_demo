import { Vector, vec } from '../Math/vector';
import { Graphic } from './Graphic';
import { BoundingBox } from '../Collision/Index';
import { Component } from '../EntityComponentSystem/Component';
import { Logger } from '../Util/Log';
import { WatchVector } from '../Math/watch-vector';
import { TransformComponent } from '../EntityComponentSystem';
import { GraphicsGroup } from '../Graphics/GraphicsGroup';
/**
 * Type guard for checking if a Graphic HasTick (used for graphics that change over time like animations)
 * @param graphic
 */
export function hasGraphicsTick(graphic) {
    return !!graphic.tick;
}
/**
 * Component to manage drawings, using with the position component
 */
export class GraphicsComponent extends Component {
    /**
     * Offset to apply to graphics by default
     */
    get offset() {
        return new WatchVector(this._offset, () => {
            this.recalculateBounds();
        });
    }
    set offset(value) {
        this._offset = value;
        this.recalculateBounds();
    }
    /**
     * Anchor to apply to graphics by default
     */
    get anchor() {
        return new WatchVector(this._anchor, () => {
            this.recalculateBounds();
        });
    }
    set anchor(value) {
        this._anchor = value;
        this.recalculateBounds();
    }
    constructor(options) {
        super();
        this._logger = Logger.getInstance();
        this._current = 'default';
        this._graphics = {};
        this._options = {};
        this.material = null;
        /**
         * Sets or gets wether any drawing should be visible in this component
         */
        this.visible = true;
        /**
         * Sets or gets wither all drawings should have an opacity applied
         */
        this.opacity = 1;
        this._offset = Vector.Zero;
        this._anchor = Vector.Half;
        /**
         * Flip all graphics horizontally along the y-axis
         */
        this.flipHorizontal = false;
        /**
         * Flip all graphics vertically along the x-axis
         */
        this.flipVertical = false;
        /**
         * If set to true graphics added to the component will be copied. This can effect performance, but is useful if you don't want
         * changes to a graphic to effect all the places it is used.
         */
        this.copyGraphics = false;
        this._localBounds = null;
        // Defaults
        options = {
            visible: this.visible,
            graphics: {},
            ...options
        };
        const { current, anchor, opacity, visible, graphics, offset, copyGraphics, onPreDraw, onPostDraw, onPreTransformDraw, onPostTransformDraw } = options;
        for (const [key, graphicOrOptions] of Object.entries(graphics)) {
            if (graphicOrOptions instanceof Graphic) {
                this._graphics[key] = graphicOrOptions;
            }
            else {
                this._graphics[key] = graphicOrOptions.graphic;
                this._options[key] = graphicOrOptions.options;
            }
        }
        this.offset = offset !== null && offset !== void 0 ? offset : this.offset;
        this.opacity = opacity !== null && opacity !== void 0 ? opacity : this.opacity;
        this.anchor = anchor !== null && anchor !== void 0 ? anchor : this.anchor;
        this.copyGraphics = copyGraphics !== null && copyGraphics !== void 0 ? copyGraphics : this.copyGraphics;
        this.onPreDraw = onPreDraw !== null && onPreDraw !== void 0 ? onPreDraw : this.onPreDraw;
        this.onPostDraw = onPostDraw !== null && onPostDraw !== void 0 ? onPostDraw : this.onPostDraw;
        this.onPreDraw = onPreTransformDraw !== null && onPreTransformDraw !== void 0 ? onPreTransformDraw : this.onPreTransformDraw;
        this.onPostTransformDraw = onPostTransformDraw !== null && onPostTransformDraw !== void 0 ? onPostTransformDraw : this.onPostTransformDraw;
        this.visible = !!visible;
        this._current = current !== null && current !== void 0 ? current : this._current;
        if (current && this._graphics[current]) {
            this.use(current);
        }
    }
    getGraphic(name) {
        return this._graphics[name];
    }
    getOptions(name) {
        return this._options[name];
    }
    /**
     * Get registered graphics names
     */
    getNames() {
        return Object.keys(this._graphics);
    }
    /**
     * Returns the currently displayed graphic
     */
    get current() {
        return this._graphics[this._current];
    }
    /**
     * Returns the currently displayed graphic offsets
     */
    get currentOptions() {
        return this._options[this._current];
    }
    /**
     * Returns all graphics associated with this component
     */
    get graphics() {
        return this._graphics;
    }
    /**
     * Returns all graphics options associated with this component
     */
    get options() {
        return this._options;
    }
    add(nameOrGraphic, graphicOrOptions, options) {
        let name = 'default';
        let graphicToSet = null;
        let optionsToSet = undefined;
        if (typeof nameOrGraphic === 'string' && graphicOrOptions instanceof Graphic) {
            name = nameOrGraphic;
            graphicToSet = graphicOrOptions;
            optionsToSet = options;
        }
        if (nameOrGraphic instanceof Graphic && !(graphicOrOptions instanceof Graphic)) {
            graphicToSet = nameOrGraphic;
            optionsToSet = graphicOrOptions;
        }
        this._graphics[name] = this.copyGraphics ? graphicToSet.clone() : graphicToSet;
        this._options[name] = this.copyGraphics ? { ...optionsToSet } : optionsToSet;
        if (name === 'default') {
            this.use('default');
        }
        return graphicToSet;
    }
    /**
     * Removes a registered graphic, if the removed graphic is the current it will switch to the default
     * @param name
     */
    remove(name) {
        delete this._graphics[name];
        delete this._options[name];
        if (this._current === name) {
            this._current = 'default';
            this.recalculateBounds();
        }
    }
    /**
     * Shows a graphic, will be removed
     * @param nameOrGraphic
     * @param options
     * @deprecated will be removed in v0.30.0, use `graphics.use(...)`
     */
    show(nameOrGraphic, options) {
        return this.use(nameOrGraphic, options);
    }
    /**
     * Use a graphic only, will set the default graphic. Returns the new [[Graphic]]
     *
     * Optionally override the stored options
     * @param nameOrGraphic
     * @param options
     */
    use(nameOrGraphic, options) {
        var _a;
        if (nameOrGraphic instanceof Graphic) {
            let graphic = nameOrGraphic;
            if (this.copyGraphics) {
                graphic = nameOrGraphic.clone();
            }
            this._current = 'default';
            this._graphics[this._current] = graphic;
            this._options[this._current] = options;
        }
        else {
            this._current = nameOrGraphic;
            this._options[this._current] = options;
            if (!(this._current in this._graphics)) {
                this._logger.warn(`Graphic ${this._current} is not registered with the graphics component owned by ${(_a = this.owner) === null || _a === void 0 ? void 0 : _a.name}. Nothing will be drawn.`);
            }
        }
        this.recalculateBounds();
        return this.current;
    }
    /**
     * Hide currently shown graphic
     */
    hide() {
        this._current = 'ex.none';
    }
    set localBounds(bounds) {
        this._localBounds = bounds;
    }
    recalculateBounds() {
        let bb = new BoundingBox();
        const graphic = this._graphics[this._current];
        const options = this._options[this._current];
        if (!graphic) {
            this._localBounds = bb;
            return;
        }
        let anchor = this.anchor;
        let offset = this.offset;
        if (options === null || options === void 0 ? void 0 : options.anchor) {
            anchor = options.anchor;
        }
        if (options === null || options === void 0 ? void 0 : options.offset) {
            offset = options.offset;
        }
        const bounds = graphic.localBounds;
        const offsetX = -bounds.width * anchor.x + offset.x;
        const offsetY = -bounds.height * anchor.y + offset.y;
        if (graphic instanceof GraphicsGroup && !graphic.useAnchor) {
            bb = graphic === null || graphic === void 0 ? void 0 : graphic.localBounds.combine(bb);
        }
        else {
            bb = graphic === null || graphic === void 0 ? void 0 : graphic.localBounds.translate(vec(offsetX, offsetY)).combine(bb);
        }
        this._localBounds = bb;
    }
    /**
     * Get local bounds of graphics component
     */
    get localBounds() {
        if (!this._localBounds || this._localBounds.hasZeroDimensions()) {
            this.recalculateBounds();
        }
        return this._localBounds;
    }
    /**
     * Get world bounds of graphics component
     */
    get bounds() {
        let bounds = this.localBounds;
        if (this.owner) {
            const tx = this.owner.get(TransformComponent);
            if (tx) {
                bounds = bounds.transform(tx.get().matrix);
            }
        }
        return bounds;
    }
    /**
     * Update underlying graphics if necessary, called internally
     * @param elapsed
     * @internal
     */
    update(elapsed, idempotencyToken = 0) {
        const graphic = this.current;
        if (graphic && hasGraphicsTick(graphic)) {
            graphic.tick(elapsed, idempotencyToken);
        }
    }
    clone() {
        const graphics = new GraphicsComponent();
        graphics._graphics = { ...this._graphics };
        graphics._options = { ...this._options };
        graphics.offset = this.offset.clone();
        graphics.opacity = this.opacity;
        graphics.anchor = this.anchor.clone();
        graphics.copyGraphics = this.copyGraphics;
        graphics.onPreDraw = this.onPreDraw;
        graphics.onPostDraw = this.onPostDraw;
        graphics.visible = this.visible;
        return graphics;
    }
}
//# sourceMappingURL=GraphicsComponent.js.map