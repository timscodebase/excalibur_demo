import { Resource } from '../Resources/Resource';
import { Sprite } from './Sprite';
import { Logger } from '../Util/Log';
import { ImageFiltering } from './Filtering';
import { Future } from '../Util/Future';
import { TextureLoader } from '../Graphics/Context/texture-loader';
import { ImageWrapping } from './Wrapping';
export const ImageSourceAttributeConstants = {
    Filtering: 'filtering',
    WrappingX: 'wrapping-x',
    WrappingY: 'wrapping-y'
};
export class ImageSource {
    /**
     * The original size of the source image in pixels
     */
    get width() {
        return this.image.naturalWidth;
    }
    /**
     * The original height of the source image in pixels
     */
    get height() {
        return this.image.naturalHeight;
    }
    /**
     * Returns true if the Texture is completely loaded and is ready
     * to be drawn.
     */
    isLoaded() {
        if (!this._src) {
            // this boosts speed of access
            this._src = this.data.src;
        }
        return !!this._src;
    }
    get image() {
        return this.data;
    }
    constructor(path, bustCacheOrOptions, filtering) {
        this._logger = Logger.getInstance();
        /**
         * Access to the underlying html image element
         */
        this.data = new Image();
        this._readyFuture = new Future();
        /**
         * Promise the resolves when the image is loaded and ready for use, does not initiate loading
         */
        this.ready = this._readyFuture.promise;
        this.path = path;
        let bustCache = false;
        let wrapping;
        if (typeof bustCacheOrOptions === 'boolean') {
            bustCache = bustCacheOrOptions;
        }
        else {
            ({ filtering, wrapping, bustCache } = { ...bustCacheOrOptions });
        }
        this._resource = new Resource(path, 'blob', bustCache);
        this.filtering = filtering !== null && filtering !== void 0 ? filtering : this.filtering;
        if (typeof wrapping === 'string') {
            this.wrapping = {
                x: wrapping,
                y: wrapping
            };
        }
        else {
            this.wrapping = wrapping !== null && wrapping !== void 0 ? wrapping : this.wrapping;
        }
        if (path.endsWith('.svg') || path.endsWith('.gif')) {
            this._logger.warn(`Image type is not fully supported, you may have mixed results ${path}. Fully supported: jpg, bmp, and png`);
        }
    }
    /**
     * Create an ImageSource from and HTML <image> tag element
     * @param image
     */
    static fromHtmlImageElement(image, options) {
        const imageSource = new ImageSource('');
        imageSource._src = 'image-element';
        imageSource.data = image;
        imageSource.data.setAttribute('data-original-src', 'image-element');
        if (options === null || options === void 0 ? void 0 : options.filtering) {
            imageSource.data.setAttribute(ImageSourceAttributeConstants.Filtering, options === null || options === void 0 ? void 0 : options.filtering);
        }
        else {
            imageSource.data.setAttribute(ImageSourceAttributeConstants.Filtering, ImageFiltering.Blended);
        }
        if (options === null || options === void 0 ? void 0 : options.wrapping) {
            let wrapping;
            if (typeof options.wrapping === 'string') {
                wrapping = {
                    x: options.wrapping,
                    y: options.wrapping
                };
            }
            else {
                wrapping = {
                    x: options.wrapping.x,
                    y: options.wrapping.y
                };
            }
            imageSource.data.setAttribute(ImageSourceAttributeConstants.WrappingX, wrapping.x);
            imageSource.data.setAttribute(ImageSourceAttributeConstants.WrappingY, wrapping.y);
        }
        else {
            imageSource.data.setAttribute(ImageSourceAttributeConstants.WrappingX, ImageWrapping.Clamp);
            imageSource.data.setAttribute(ImageSourceAttributeConstants.WrappingY, ImageWrapping.Clamp);
        }
        TextureLoader.checkImageSizeSupportedAndLog(image);
        imageSource._readyFuture.resolve(image);
        return imageSource;
    }
    /**
     * Should excalibur add a cache busting querystring? By default false.
     * Must be set before loading
     */
    get bustCache() {
        return this._resource.bustCache;
    }
    set bustCache(val) {
        this._resource.bustCache = val;
    }
    /**
     * Begins loading the image and returns a promise that resolves when the image is loaded
     */
    async load() {
        var _a, _b, _c, _d;
        if (this.isLoaded()) {
            return this.data;
        }
        try {
            // Load base64 or blob if needed
            let url;
            if (!this.path.includes('data:image/')) {
                const blob = await this._resource.load();
                url = URL.createObjectURL(blob);
            }
            else {
                url = this.path;
            }
            // Decode the image
            const image = new Image();
            // Use Image.onload over Image.decode()
            // https://bugs.chromium.org/p/chromium/issues/detail?id=1055828#c7
            // Otherwise chrome will throw still Image.decode() failures for large textures
            const loadedFuture = new Future();
            image.onload = () => loadedFuture.resolve();
            image.src = url;
            image.setAttribute('data-original-src', this.path);
            await loadedFuture.promise;
            // Set results
            // We defer loading the texture into webgl until the first draw that way we avoid a singleton
            // and for the multi-engine case the texture needs to be created in EACH webgl context to work
            // See image-renderer.ts draw()
            this.data = image;
            // emit warning if potentially too big
            TextureLoader.checkImageSizeSupportedAndLog(this.data);
        }
        catch (error) {
            throw `Error loading ImageSource from path '${this.path}' with error [${error.message}]`;
        }
        // Do a bad thing to pass the filtering as an attribute
        this.data.setAttribute(ImageSourceAttributeConstants.Filtering, this.filtering);
        this.data.setAttribute(ImageSourceAttributeConstants.WrappingX, (_b = (_a = this.wrapping) === null || _a === void 0 ? void 0 : _a.x) !== null && _b !== void 0 ? _b : ImageWrapping.Clamp);
        this.data.setAttribute(ImageSourceAttributeConstants.WrappingY, (_d = (_c = this.wrapping) === null || _c === void 0 ? void 0 : _c.y) !== null && _d !== void 0 ? _d : ImageWrapping.Clamp);
        // todo emit complete
        this._readyFuture.resolve(this.data);
        return this.data;
    }
    /**
     * Build a sprite from this ImageSource
     */
    toSprite() {
        return Sprite.from(this);
    }
    /**
     * Unload images from memory
     */
    unload() {
        this.data = new Image();
    }
}
//# sourceMappingURL=ImageSource.js.map