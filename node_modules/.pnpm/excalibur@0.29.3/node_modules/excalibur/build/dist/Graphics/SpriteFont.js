import { Vector } from '../Math/vector';
import { Logger } from '../Util/Log';
import { Graphic } from './Graphic';
import { BoundingBox } from '../Collision/BoundingBox';
export class SpriteFont extends Graphic {
    constructor(options) {
        super(options);
        this._text = '';
        this.alphabet = '';
        this.shadow = null;
        this.caseInsensitive = false;
        this.spacing = 0;
        this.lineHeight = undefined;
        this._logger = Logger.getInstance();
        const { alphabet, spriteSheet, caseInsensitive, spacing, shadow, lineHeight } = options;
        this.alphabet = alphabet;
        this.spriteSheet = spriteSheet;
        this.caseInsensitive = caseInsensitive !== null && caseInsensitive !== void 0 ? caseInsensitive : this.caseInsensitive;
        this.spacing = spacing !== null && spacing !== void 0 ? spacing : this.spacing;
        this.shadow = shadow !== null && shadow !== void 0 ? shadow : this.shadow;
        this.lineHeight = lineHeight !== null && lineHeight !== void 0 ? lineHeight : this.lineHeight;
    }
    _getCharacterSprites(text) {
        const results = [];
        // handle case insensitive
        const textToRender = this.caseInsensitive ? text.toLocaleLowerCase() : text;
        const alphabet = this.caseInsensitive ? this.alphabet.toLocaleLowerCase() : this.alphabet;
        // for each letter in text
        for (let letterIndex = 0; letterIndex < textToRender.length; letterIndex++) {
            // find the sprite index in alphabet , if there is an error pick the first
            const letter = textToRender[letterIndex];
            let spriteIndex = alphabet.indexOf(letter);
            if (spriteIndex === -1) {
                spriteIndex = 0;
                this._logger.warnOnce(`SpriteFont - Cannot find letter '${letter}' in configured alphabet '${alphabet}'.`);
                this._logger.warnOnce('There maybe be more issues in the SpriteFont configuration. No additional warnings will be logged.');
            }
            const letterSprite = this.spriteSheet.sprites[spriteIndex];
            if (letterSprite) {
                results.push(letterSprite);
            }
            else {
                this._logger.warnOnce(`SpriteFont - Cannot find sprite for '${letter}' at index '${spriteIndex}' in configured SpriteSheet`);
                this._logger.warnOnce('There maybe be more issues in the SpriteFont configuration. No additional warnings will be logged.');
            }
        }
        return results;
    }
    measureText(text, maxWidth) {
        const lines = this._getLinesFromText(text, maxWidth);
        const maxWidthLine = lines.reduce((a, b) => {
            return a.length > b.length ? a : b;
        });
        const sprites = this._getCharacterSprites(maxWidthLine);
        let width = 0;
        let height = 0;
        for (const sprite of sprites) {
            width += sprite.width + this.spacing;
            height = Math.max(height, sprite.height);
        }
        return BoundingBox.fromDimension(width, height * lines.length, Vector.Zero);
    }
    _drawImage(ex, x, y, maxWidth) {
        var _a;
        let xCursor = 0;
        let yCursor = 0;
        let height = 0;
        const lines = this._getLinesFromText(this._text, maxWidth);
        for (const line of lines) {
            for (const sprite of this._getCharacterSprites(line)) {
                // draw it in the right spot and increase the cursor by sprite width
                sprite.draw(ex, x + xCursor, y + yCursor);
                xCursor += sprite.width + this.spacing;
                height = Math.max(height, sprite.height);
            }
            xCursor = 0;
            yCursor += (_a = this.lineHeight) !== null && _a !== void 0 ? _a : height;
        }
    }
    render(ex, text, _color, x, y, maxWidth) {
        // SpriteFont doesn't support _color, yet...
        this._text = text;
        const bounds = this.measureText(text, maxWidth);
        this.width = bounds.width;
        this.height = bounds.height;
        if (this.shadow) {
            ex.save();
            ex.translate(this.shadow.offset.x, this.shadow.offset.y);
            this._preDraw(ex, x, y);
            this._drawImage(ex, 0, 0, maxWidth);
            this._postDraw(ex);
            ex.restore();
        }
        this._preDraw(ex, x, y);
        this._drawImage(ex, 0, 0, maxWidth);
        this._postDraw(ex);
    }
    clone() {
        return new SpriteFont({
            alphabet: this.alphabet,
            spriteSheet: this.spriteSheet,
            spacing: this.spacing
        });
    }
    _getLinesFromText(text, maxWidth) {
        if (this._cachedText === text && this._cachedRenderWidth === maxWidth) {
            return this._cachedLines;
        }
        const lines = text.split('\n');
        if (maxWidth == null) {
            return lines;
        }
        // If the current line goes past the maxWidth, append a new line without modifying the underlying text.
        for (let i = 0; i < lines.length; i++) {
            let line = lines[i];
            let newLine = '';
            // Note: we subtract the spacing to counter the initial padding on the left side.
            if (this.measureText(line).width > maxWidth) {
                while (this.measureText(line).width > maxWidth) {
                    newLine = line[line.length - 1] + newLine;
                    line = line.slice(0, -1); // Remove last character from line
                }
                // Update the array with our new values
                lines[i] = line;
                lines[i + 1] = newLine;
            }
        }
        this._cachedText = text;
        this._cachedLines = lines;
        this._cachedRenderWidth = maxWidth;
        return lines;
    }
}
//# sourceMappingURL=SpriteFont.js.map