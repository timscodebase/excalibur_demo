import { GraphicsComponent } from './GraphicsComponent';
import { EnterViewPortEvent, ExitViewPortEvent } from '../Events';
import { TransformComponent } from '../EntityComponentSystem/Components/TransformComponent';
import { System, SystemType } from '../EntityComponentSystem/System';
import { ParallaxComponent } from './ParallaxComponent';
import { Vector } from '../Math/vector';
import { CoordPlane } from '../Math/coord-plane';
import { SystemPriority } from '../EntityComponentSystem';
export class OffscreenSystem extends System {
    constructor(world) {
        super();
        this.world = world;
        this.systemType = SystemType.Draw;
        this.priority = SystemPriority.Higher;
        this.query = this.world.query([TransformComponent, GraphicsComponent]);
    }
    initialize(world, scene) {
        this._camera = scene.camera;
        this._screen = scene.engine.screen;
    }
    update() {
        this._worldBounds = this._screen.getWorldBounds();
        let transform;
        let graphics;
        let maybeParallax;
        for (const entity of this.query.entities) {
            graphics = entity.get(GraphicsComponent);
            transform = entity.get(TransformComponent);
            maybeParallax = entity.get(ParallaxComponent);
            let parallaxOffset;
            if (maybeParallax) {
                // We use the Tiled formula
                // https://doc.mapeditor.org/en/latest/manual/layers/#parallax-scrolling-factor
                // cameraPos * (1 - parallaxFactor)
                const oneMinusFactor = Vector.One.sub(maybeParallax.parallaxFactor);
                parallaxOffset = this._camera.pos.scale(oneMinusFactor);
            }
            // Figure out if entities are offscreen
            const entityOffscreen = this._isOffscreen(transform, graphics, parallaxOffset);
            if (entityOffscreen && !entity.hasTag('ex.offscreen')) {
                entity.events.emit('exitviewport', new ExitViewPortEvent(entity));
                entity.addTag('ex.offscreen');
            }
            if (!entityOffscreen && entity.hasTag('ex.offscreen')) {
                entity.events.emit('enterviewport', new EnterViewPortEvent(entity));
                entity.removeTag('ex.offscreen');
            }
        }
    }
    _isOffscreen(transform, graphics, parallaxOffset) {
        if (transform.coordPlane === CoordPlane.World) {
            let bounds = graphics.localBounds;
            if (parallaxOffset) {
                bounds = bounds.translate(parallaxOffset);
            }
            const transformedBounds = bounds.transform(transform.get().matrix);
            const graphicsOffscreen = !this._worldBounds.overlaps(transformedBounds);
            return graphicsOffscreen;
        }
        else {
            // TODO screen coordinates
            return false;
        }
    }
}
//# sourceMappingURL=OffscreenSystem.js.map