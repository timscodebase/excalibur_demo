import { Color } from '../Color';
export class Debug {
    static registerGraphicsContext(ctx) {
        Debug._ctx = ctx;
    }
    static draw(debugDrawCall) {
        this._drawCalls.push(debugDrawCall);
    }
    static drawPoint(point, options) {
        Debug.draw(ctx => {
            ctx.debug.drawPoint(point, options);
        });
    }
    static drawLine(start, end, options) {
        Debug.draw(ctx => {
            ctx.debug.drawLine(start, end, options);
        });
    }
    static drawLines(points, options) {
        if (points.length > 1) {
            Debug.draw(ctx => {
                for (let i = 0; i < points.length - 1; i++) {
                    ctx.debug.drawLine(points[i], points[i + 1], options);
                }
            });
        }
    }
    static drawText(text, pos) {
        Debug.draw(ctx => {
            ctx.debug.drawText(text, pos);
        });
    }
    static drawPolygon(points, options) {
        if (points.length > 1) {
            Debug.draw(ctx => {
                const firstPoint = points[0];
                const polygon = [...points, firstPoint];
                for (let i = 0; i < polygon.length - 1; i++) {
                    ctx.debug.drawLine(polygon[i], polygon[i + 1], options);
                }
            });
        }
    }
    static drawCircle(center, radius, options) {
        const { color, strokeColor, width } = {
            color: Color.Black,
            strokeColor: undefined,
            width: undefined,
            ...options
        };
        Debug.draw(ctx => {
            ctx.drawCircle(center, radius, color, strokeColor, width);
        });
    }
    static drawBounds(boundingBox, options) {
        Debug.draw(ctx => {
            ctx.debug.drawRect(boundingBox.left, boundingBox.top, boundingBox.width, boundingBox.height, options);
        });
    }
    static drawRay(ray, options) {
        const { distance, color } = {
            color: Color.Blue,
            distance: 10,
            ...options
        };
        Debug.draw((ctx) => {
            const start = ray.pos;
            const end = ray.pos.add(ray.dir.scale(distance));
            ctx.debug.drawLine(start, end, { color });
        });
    }
    static flush(ctx) {
        ctx.save();
        ctx.z = Debug.z;
        for (const drawCall of Debug._drawCalls) {
            drawCall(ctx);
        }
        ctx.restore();
        Debug.clear();
    }
    static clear() {
        Debug._drawCalls.length = 0;
    }
}
Debug._drawCalls = [];
Debug.z = Infinity;
//# sourceMappingURL=Debug.js.map