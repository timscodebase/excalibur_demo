import { Observable } from '../Util/Observable';
export class TagQuery {
    constructor(requiredTags) {
        this.requiredTags = requiredTags;
        this.tags = new Set();
        this.entities = [];
        /**
         * This fires right after the component is added
         */
        this.entityAdded$ = new Observable();
        /**
         * This fires right before the component is actually removed from the entity, it will still be available for cleanup purposes
         */
        this.entityRemoved$ = new Observable();
        if (requiredTags.length === 0) {
            throw new Error('Cannot create tag query without tags');
        }
        for (const tag of requiredTags) {
            this.tags.add(tag);
        }
        this.id = TagQuery.createId(requiredTags);
    }
    static createId(requiredComponents) {
        return requiredComponents.slice().sort().join('-');
    }
    checkAndAdd(entity) {
        if (!this.entities.includes(entity) && entity.hasAllTags(Array.from(this.tags))) {
            this.entities.push(entity);
            this.entityAdded$.notifyAll(entity);
            return true;
        }
        return false;
    }
    removeEntity(entity) {
        const index = this.entities.indexOf(entity);
        if (index > -1) {
            this.entities.splice(index, 1);
            this.entityRemoved$.notifyAll(entity);
        }
    }
    /**
     * Returns a list of entities that match the query
     * @param sort Optional sorting function to sort entities returned from the query
     */
    getEntities(sort) {
        if (sort) {
            this.entities.sort(sort);
        }
        return this.entities;
    }
}
//# sourceMappingURL=TagQuery.js.map