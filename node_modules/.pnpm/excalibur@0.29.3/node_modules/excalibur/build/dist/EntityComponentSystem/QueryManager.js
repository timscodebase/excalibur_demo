import { Query } from './Query';
import { TagQuery } from './TagQuery';
/**
 * The query manager is responsible for updating all queries when entities/components change
 */
export class QueryManager {
    constructor(_world) {
        this._world = _world;
        this._queries = new Map();
        this._addComponentHandlers = new Map();
        this._removeComponentHandlers = new Map();
        this._componentToQueriesIndex = new Map();
        this._tagQueries = new Map();
        this._addTagHandlers = new Map();
        this._removeTagHandlers = new Map();
        this._tagToQueriesIndex = new Map();
        this._createAddComponentHandler = (entity) => (c) => {
            this.addComponent(entity, c);
        };
        this._createRemoveComponentHandler = (entity) => (c) => {
            this.removeComponent(entity, c);
        };
        this._createAddTagHandler = (entity) => (tag) => {
            this.addTag(entity, tag);
        };
        this._createRemoveTagHandler = (entity) => (tag) => {
            this.removeTag(entity, tag);
        };
    }
    createQuery(requiredComponents) {
        const id = Query.createId(requiredComponents);
        if (this._queries.has(id)) {
            // short circuit if query is already created
            return this._queries.get(id);
        }
        const query = new Query(requiredComponents);
        this._queries.set(query.id, query);
        // index maintenance
        for (const component of requiredComponents) {
            const queries = this._componentToQueriesIndex.get(component);
            if (!queries) {
                this._componentToQueriesIndex.set(component, [query]);
            }
            else {
                queries.push(query);
            }
        }
        for (const entity of this._world.entities) {
            this.addEntity(entity);
        }
        return query;
    }
    createTagQuery(requiredTags) {
        const id = TagQuery.createId(requiredTags);
        if (this._tagQueries.has(id)) {
            // short circuit if query is already created
            return this._tagQueries.get(id);
        }
        const query = new TagQuery(requiredTags);
        this._tagQueries.set(query.id, query);
        // index maintenance
        for (const tag of requiredTags) {
            const queries = this._tagToQueriesIndex.get(tag);
            if (!queries) {
                this._tagToQueriesIndex.set(tag, [query]);
            }
            else {
                queries.push(query);
            }
        }
        for (const entity of this._world.entities) {
            this.addEntity(entity);
        }
        return query;
    }
    /**
     * Scans queries and locates any that need this entity added
     * @param entity
     */
    addEntity(entity) {
        const maybeAddComponent = this._addComponentHandlers.get(entity);
        const maybeRemoveComponent = this._removeComponentHandlers.get(entity);
        const addComponent = maybeAddComponent !== null && maybeAddComponent !== void 0 ? maybeAddComponent : this._createAddComponentHandler(entity);
        const removeComponent = maybeRemoveComponent !== null && maybeRemoveComponent !== void 0 ? maybeRemoveComponent : this._createRemoveComponentHandler(entity);
        this._addComponentHandlers.set(entity, addComponent);
        this._removeComponentHandlers.set(entity, removeComponent);
        const maybeAddTag = this._addTagHandlers.get(entity);
        const maybeRemoveTag = this._removeTagHandlers.get(entity);
        const addTag = maybeAddTag !== null && maybeAddTag !== void 0 ? maybeAddTag : this._createAddTagHandler(entity);
        const removeTag = maybeRemoveTag !== null && maybeRemoveTag !== void 0 ? maybeRemoveTag : this._createRemoveTagHandler(entity);
        this._addTagHandlers.set(entity, addTag);
        this._removeTagHandlers.set(entity, removeTag);
        for (const query of this._queries.values()) {
            query.checkAndAdd(entity);
        }
        for (const tagQuery of this._tagQueries.values()) {
            tagQuery.checkAndAdd(entity);
        }
        entity.componentAdded$.subscribe(addComponent);
        entity.componentRemoved$.subscribe(removeComponent);
        entity.tagAdded$.subscribe(addTag);
        entity.tagRemoved$.subscribe(removeTag);
    }
    /**
     * Scans queries and locates any that need this entity removed
     * @param entity
     */
    removeEntity(entity) {
        // Handle components
        const addComponent = this._addComponentHandlers.get(entity);
        const removeComponent = this._removeComponentHandlers.get(entity);
        for (const query of this._queries.values()) {
            query.removeEntity(entity);
        }
        if (addComponent) {
            entity.componentAdded$.unsubscribe(addComponent);
        }
        if (removeComponent) {
            entity.componentRemoved$.unsubscribe(removeComponent);
        }
        // Handle tags
        const addTag = this._addTagHandlers.get(entity);
        const removeTag = this._removeTagHandlers.get(entity);
        for (const tagQuery of this._tagQueries.values()) {
            tagQuery.removeEntity(entity);
        }
        if (addTag) {
            entity.tagAdded$.unsubscribe(addTag);
        }
        if (removeTag) {
            entity.tagRemoved$.unsubscribe(removeTag);
        }
    }
    /**
     * Updates any queries when a component is added to an entity
     * @param entity
     * @param component
     */
    addComponent(entity, component) {
        var _a;
        const queries = (_a = this._componentToQueriesIndex.get(component.constructor)) !== null && _a !== void 0 ? _a : [];
        for (const query of queries) {
            query.checkAndAdd(entity);
        }
    }
    /**
     * Updates any queries when a component is removed from an entity
     * @param entity
     * @param component
     */
    removeComponent(entity, component) {
        var _a;
        const queries = (_a = this._componentToQueriesIndex.get(component.constructor)) !== null && _a !== void 0 ? _a : [];
        for (const query of queries) {
            query.removeEntity(entity);
        }
    }
    /**
     * Updates any queries when a tag is added to an entity
     * @param entity
     * @param tag
     */
    addTag(entity, tag) {
        var _a;
        const queries = (_a = this._tagToQueriesIndex.get(tag)) !== null && _a !== void 0 ? _a : [];
        for (const query of queries) {
            query.checkAndAdd(entity);
        }
    }
    /**
     * Updates any queries when a component is removed from an entity
     * @param entity
     * @param tag
     */
    removeTag(entity, tag) {
        var _a;
        const queries = (_a = this._tagToQueriesIndex.get(tag)) !== null && _a !== void 0 ? _a : [];
        for (const query of queries) {
            query.removeEntity(entity);
        }
    }
}
//# sourceMappingURL=QueryManager.js.map