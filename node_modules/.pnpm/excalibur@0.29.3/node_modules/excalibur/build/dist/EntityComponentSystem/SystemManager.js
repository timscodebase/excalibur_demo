import { System } from './System';
import { removeItemFromArray } from '../Util/Util';
/**
 *
 */
export function isSystemConstructor(x) {
    var _a, _b;
    return !!(x === null || x === void 0 ? void 0 : x.prototype) && !!((_b = (_a = x === null || x === void 0 ? void 0 : x.prototype) === null || _a === void 0 ? void 0 : _a.constructor) === null || _b === void 0 ? void 0 : _b.name);
}
/**
 * The SystemManager is responsible for keeping track of all systems in a scene.
 * Systems are scene specific
 */
export class SystemManager {
    constructor(_world) {
        this._world = _world;
        /**
         * List of systems, to add a new system call [[SystemManager.addSystem]]
         */
        this.systems = [];
        this.initialized = false;
    }
    /**
     * Get a system registered in the manager by type
     * @param systemType
     */
    get(systemType) {
        return this.systems.find((s) => s instanceof systemType);
    }
    /**
     * Adds a system to the manager, it will now be updated every frame
     * @param systemOrCtor
     */
    addSystem(systemOrCtor) {
        let system;
        if (systemOrCtor instanceof System) {
            system = systemOrCtor;
        }
        else {
            system = new systemOrCtor(this._world);
        }
        this.systems.push(system);
        this.systems.sort((a, b) => a.priority - b.priority);
        // If systems are added and the manager has already been init'd
        // then immediately init the system
        if (this.initialized && system.initialize) {
            system.initialize(this._world, this._world.scene);
        }
    }
    /**
     * Removes a system from the manager, it will no longer be updated
     * @param system
     */
    removeSystem(system) {
        removeItemFromArray(system, this.systems);
    }
    /**
     * Initialize all systems in the manager
     *
     * Systems added after initialize() will be initialized on add
     */
    initialize() {
        if (!this.initialized) {
            this.initialized = true;
            for (const s of this.systems) {
                if (s.initialize) {
                    s.initialize(this._world, this._world.scene);
                }
            }
        }
    }
    /**
     * Updates all systems
     * @param type whether this is an update or draw system
     * @param scene context reference
     * @param delta time in milliseconds
     */
    updateSystems(type, scene, delta) {
        const systems = this.systems.filter((s) => s.systemType === type);
        for (const s of systems) {
            if (s.preupdate) {
                s.preupdate(scene, delta);
            }
        }
        for (const s of systems) {
            s.update(delta);
        }
        for (const s of systems) {
            if (s.postupdate) {
                s.postupdate(scene, delta);
            }
        }
    }
    clear() {
        for (let i = this.systems.length - 1; i >= 0; i--) {
            this.removeSystem(this.systems[i]);
        }
    }
}
//# sourceMappingURL=SystemManager.js.map