"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Runner = exports.test = exports.expectLoaded = exports.expectPage = exports.ExTestContext = void 0;
const fs = require("fs");
const http = require("http");
const nodestatic = require("@brettz9/node-static");
const readline = require("readline");
const pixelmatch = require("pixelmatch");
const pngjs_1 = require("pngjs");
const puppeteer = require("puppeteer");
exports.ExTestContext = {
    tests: [],
    interactive: false,
    page: null,
    passed: 0,
    failed: 0
};
const updateExpected = (expectedFile, actualFile) => {
    const actual = pngjs_1.PNG.sync.read(fs.readFileSync(actualFile));
    const userInterface = readline.createInterface({
        input: process.stdin,
        output: process.stdout
    });
    return new Promise((resolve, reject) => {
        userInterface.question('Update expected image? (y/n): ', response => {
            if (response.toLocaleLowerCase().includes('y')) {
                console.log(`Updating ${expectedFile}...`);
                const actualBuffer = pngjs_1.PNG.sync.write(actual);
                checkPath(expectedFile, true);
                fs.writeFileSync(expectedFile, actualBuffer);
                userInterface.close();
                resolve();
            }
            else {
                userInterface.close();
                reject();
            }
        });
    });
};
async function imageMatch(expectedFile, actualFile) {
    const actual = pngjs_1.PNG.sync.read(fs.readFileSync(actualFile));
    if (!checkPath(expectedFile)) {
        console.log(`[ERROR]: Expected image: [${expectedFile}] does not exist!`);
        if (exports.ExTestContext.interactive) {
            await updateExpected(expectedFile, actualFile).catch(() => {
                exports.ExTestContext.failed++;
            });
        }
        else {
            exports.ExTestContext.failed++;
        }
    }
    const expected = pngjs_1.PNG.sync.read(fs.readFileSync(expectedFile));
    const { width, height } = expected;
    const diff = new pngjs_1.PNG({ width, height });
    const pixelDiff = pixelmatch(expected.data, actual.data, diff.data, width, height, { threshold: 0.1 });
    if (pixelDiff > 100) {
        console.error('\x1b[31m%s\x1b[0m', `[ERROR]: Image ${expectedFile} did not match acutal ${actualFile}, ${pixelDiff} different!`);
        const diffImage = pngjs_1.PNG.sync.write(diff);
        console.log('Diff image: ', 'data:image/png;base64,' + diffImage.toString('base64'));
        const fileSplit = actualFile.split('/');
        const filename = fileSplit[fileSplit.length - 1];
        const path = fileSplit.slice(0, -1);
        checkPath('./' + path.join('/'), true);
        fs.writeFileSync('./' + path.join('/') + '/diff-' + filename, diffImage);
        if (exports.ExTestContext.interactive) {
            await updateExpected(expectedFile, actualFile).catch(() => {
                exports.ExTestContext.failed++;
            });
        }
        else {
            exports.ExTestContext.failed++;
        }
    }
}
const isLoaded = async (page) => {
    await page.waitForSelector('#excalibur-play', { visible: true });
    // FIXME: see if this wait for timeout is still needed.
    // on possiblity is to use node timers, see also: https://stackoverflow.com/a/77078415
    // ```typescript
    // ...
    // 
    // import { setTimeout } from "node:timers/promises";
    // ...
    // ```
    // await page.waitForTimeout(1000); // give it a second
};
const clickPlayButton = async (page) => {
    const start = await page.$('#excalibur-play');
    await start.click();
    // FIXME: see if this is still needed, possible removal if not
    // Left-over roots :( excalibur bug
    await page.evaluate(() => {
        const root = document.querySelector('#excalibur-play-root');
        if (root) {
            document.body.removeChild(root);
        }
    });
};
const checkPath = (actualFilePath, create = false) => {
    if (create) {
        const fileSplit = actualFilePath.split('/');
        const path = fileSplit.slice(0, -1);
        fs.mkdirSync('./' + path.join('/'), { recursive: true });
        return true;
    }
    return fs.existsSync(actualFilePath);
};
const expectLoadedInternal = async (page) => {
    if (!page) {
        return false;
    }
    try {
        await isLoaded(page);
        await clickPlayButton(page);
    }
    catch (e) {
        console.error('\x1b[31m%s\x1b[0m', '[ERROR]: Could not confirm Excalibur loaded properly', e);
        // swallow
    }
};
const expectPageInternal = (page, pageName, actualFilePath) => {
    if (!page) {
        return {
            toBe: async (expectFilePath) => {
                console.error('\x1b[31m%s\x1b[0m', '[ERROR]: Context not created, did you create a Runner?');
                process.exit(1);
            }
        };
    }
    return {
        toBe: async (expectedFilePath) => {
            console.log(`\tExpect: ${pageName}`);
            checkPath(actualFilePath, true);
            await page.screenshot({ path: actualFilePath });
            try {
                await imageMatch(expectedFilePath, actualFilePath);
                exports.ExTestContext.passed++;
            }
            catch {
                exports.ExTestContext.failed++;
            }
        }
    };
};
const expectPage = (name, path) => expectPageInternal(exports.ExTestContext.page, name, path);
exports.expectPage = expectPage;
const expectLoaded = async () => expectLoadedInternal(exports.ExTestContext.page);
exports.expectLoaded = expectLoaded;
const test = (name, testContext) => {
    exports.ExTestContext.tests.push([name, testContext]);
};
exports.test = test;
class Runner {
    constructor(options) {
        var _a, _b, _c;
        this._url = options.url;
        this._dir = options.dir;
        this._port = (_a = options.port) !== null && _a !== void 0 ? _a : 8080;
        this._interactive = (_b = options.interactive) !== null && _b !== void 0 ? _b : false;
        this._showLogs = (_c = options.showLogs) !== null && _c !== void 0 ? _c : false;
        exports.ExTestContext.interactive = this._interactive;
    }
    async start() {
        var _a;
        if (this._dir) {
            // start local server 
            const file = new nodestatic.Server(this._dir);
            const server = http.createServer(function (req, res) {
                file.serve(req, res);
            });
            const listening = new Promise((resolve, reject) => {
                server.listen(this._port, () => {
                    resolve();
                });
                server.on('error', () => {
                    reject();
                });
            });
            await listening;
            this._url = `http://localhost:${this._port}/`;
        }
        const browser = await puppeteer.launch({
            dumpio: this._showLogs,
            args: [
                '--window-size=800,600',
            ],
        });
        const page = await browser.newPage();
        await page.goto((_a = this._url) !== null && _a !== void 0 ? _a : '/');
        exports.ExTestContext.page = page;
        try {
            for (let test of exports.ExTestContext.tests) {
                console.log(`Test: ${test[0]}`);
                await (test[1](page));
            }
        }
        finally {
            await browser.close();
            if (exports.ExTestContext.failed) {
                console.log('\x1b[31m%s\x1b[0m', `Tests failed: ${exports.ExTestContext.failed}`);
                console.log('\x1b[31m%s\x1b[0m', `Tests passed: ${exports.ExTestContext.passed}`);
                process.exit(1);
            }
            console.log('\x1b[32m%s\x1b[0m', `Test Success! ${exports.ExTestContext.passed} Tests Passed`);
            process.exit(0);
        }
    }
}
exports.Runner = Runner;
//# sourceMappingURL=index.js.map